#include "FWCore/Framework/interface/Frameworkfwd.h"
#include "FWCore/Framework/interface/one/EDAnalyzer.h"
#include "FWCore/Framework/interface/Event.h"
#include "FWCore/Framework/interface/EventSetup.h"
#include "FWCore/Framework/interface/MakerMacros.h"
#include "CommonTools/UtilAlgos/interface/TFileService.h"
#include "FWCore/ServiceRegistry/interface/Service.h"
#include "FWCore/ParameterSet/interface/ParameterSet.h"

#include "DataFormats/PatCandidates/interface/Jet.h"
#include "DataFormats/RecoVertex/interface/Vertex.h"
#include "DataFormats/BeamSpot/interface/BeamSpot.h"
#include "DataFormats/Math/interface/XYZPointF.h"
#include "DataFormats/HepMCCandidate/interface/HepMCProduct.h"

#include "TTree.h"
#include "TFile.h"

#include <memory>

class JetTreeProducer : public edm::one::EDAnalyzer<edm::one::SharedResources> {
public:
  explicit JetTreeProducer(const edm::ParameterSet&);
  ~JetTreeProducer() override = default;

private:
  void beginJob() override;
  void analyze(const edm::Event&, const edm::EventSetup&) override;
  void endJob() override;

  edm::EDGetTokenT<std::vector<pat::Jet>> jetsToken_;
  
  // Add tokens for primary vertex, beam spot, and generated particles
  edm::EDGetTokenT<std::vector<reco::Vertex>> pvsToken_;
  edm::EDGetTokenT<reco::BeamSpot> bsToken_;
  edm::EDGetTokenT<math::XYZPointF> genpToken_;
  edm::EDGetTokenT<edm::HepMCProduct> genvertexToken_;

  // -- Output tree
  edm::Service<TFileService> fs_;

  TTree* tree_;

  float pt_, eta_, phi_, mass_;
  float pvs_x_, pvs_y_, pvs_z_; // For primary vertex position
  float beamspot_x_, beamspot_y_, beamspot_z_; // For beam spot position
  float genparticles_z_; // For generated particles z-position
  float genvertex_z_; // For generated vertex z-position
};

JetTreeProducer::JetTreeProducer(const edm::ParameterSet& iConfig) {
  jetsToken_ = consumes<std::vector<pat::Jet>>(iConfig.getParameter<edm::InputTag>("jetTag"));
  
  // Initialize new tokens for primary vertex, beam spot, and generated particles
  pvsToken_ = consumes<std::vector<reco::Vertex>>(iConfig.getParameter<edm::InputTag>("pvTag"));
  bsToken_ = consumes<reco::BeamSpot>(edm::InputTag("offlineBeamSpot"));
  genpToken_ = consumes<math::XYZPointF>(edm::InputTag("genParticles:xyz0"));
  genvertexToken_ = consumes<edm::HepMCProduct>(edm::InputTag("generatorSmeared"));
}

void JetTreeProducer::beginJob() {
  tree_ = fs_->make<TTree>("JetTree", "JetTree");

  // Branches for jet kinematics
  tree_->Branch("pt", &pt_, "pt/F");
  tree_->Branch("eta", &eta_, "eta/F");
  tree_->Branch("phi", &phi_, "phi/F");
  tree_->Branch("mass", &mass_, "mass/F");

  // Branches for primary vertex
  tree_->Branch("pvs_x", &pvs_x_, "pvs_x/F");
  tree_->Branch("pvs_y", &pvs_y_, "pvs_y/F");
  tree_->Branch("pvs_z", &pvs_z_, "pvs_z/F");

  // Branches for beam spot
  tree_->Branch("beamspot_x", &beamspot_x_, "beamspot_x/F");
  tree_->Branch("beamspot_y", &beamspot_y_, "beamspot_y/F");
  tree_->Branch("beamspot_z", &beamspot_z_, "beamspot_z/F");

  // Branches for generated particles
  tree_->Branch("genparticles_z", &genparticles_z_, "genparticles_z/F");
  tree_->Branch("genvertex_z", &genvertex_z_, "genvertex_z/F");
}

void JetTreeProducer::analyze(const edm::Event& iEvent, const edm::EventSetup&) {
  edm::Handle<std::vector<pat::Jet>> jets;
  iEvent.getByToken(jetsToken_, jets);

  // Retrieve primary vertices, beam spot, and generated particles
  edm::Handle<std::vector<reco::Vertex>> pvs;
  iEvent.getByToken(pvsToken_, pvs);

  edm::Handle<reco::BeamSpot> beamspot;
  iEvent.getByToken(bsToken_, beamspot);

  edm::Handle<math::XYZPointF> genp;
  iEvent.getByToken(genpToken_, genp);

  edm::Handle<edm::HepMCProduct> genvertex;
  iEvent.getByToken(genvertexToken_, genvertex);

  // Loop over jets and fill tree
  int jetIndex = 0;
  for (const auto& jet : *jets) {
    pt_ = jet.pt();
    eta_ = jet.eta();
    phi_ = jet.phi();
    mass_ = jet.mass();
    tree_->Fill();
    jetIndex++;

    if (jetIndex >= 5) break;  // limit to first 5 jets
  }

  // Fill primary vertex information (taking the first vertex if available)
  if (!pvs->empty()) {
    pvs_x_ = pvs->front().x();
    pvs_y_ = pvs->front().y();
    pvs_z_ = pvs->front().z();
  }

  // Fill beam spot information
  if (beamspot.isValid()) {
    beamspot_x_ = beamspot->x0();
    beamspot_y_ = beamspot->y0();
    beamspot_z_ = beamspot->z0();
  }

  // Fill generated particle z-position
  if (genp.isValid()) {
    genparticles_z_ = genp->z();
  }

  // Fill generated vertex z-position
  if (genvertex.isValid()) {
    genvertex_z_ = genvertex->get_vertex().z();
  }
}

void JetTreeProducer::endJob() {
  // Optionally, finalize the job here (close files, etc.)
}

// Define this as a plug-in
DEFINE_FWK_MODULE(JetTreeProducer);

